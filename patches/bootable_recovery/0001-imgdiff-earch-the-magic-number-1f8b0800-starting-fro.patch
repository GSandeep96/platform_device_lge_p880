From 73ed48007a8e9e4db99c661182020ded6d482340 Mon Sep 17 00:00:00 2001
From: streambinder <davidepucci@hiddenhost.org>
Date: Mon, 29 Dec 2014 23:55:14 +0100
Subject: [PATCH] imgdiff: earch the magic number 1f8b0800 starting from the
 ramdisk page Imgdiff tool searches the magic number 1f8b0800 to find gzipped
 block. But the previous algorithm did not handle the case when that byte
 sequence appears spuriously in the file. To avoid this, this commit tries to
 match the magic number starting from the ramdisk pages (skipping the kernel
 pages).

---
 applypatch/Android.mk |  2 +-
 applypatch/imgdiff.c  | 13 +++++++++++--
 2 files changed, 12 insertions(+), 3 deletions(-)

diff --git a/applypatch/Android.mk b/applypatch/Android.mk
index ef57f24..eca1a31 100644
--- a/applypatch/Android.mk
+++ b/applypatch/Android.mk
@@ -50,7 +50,7 @@ include $(CLEAR_VARS)
 LOCAL_SRC_FILES := imgdiff.c utils.c bsdiff.c
 LOCAL_MODULE := imgdiff
 LOCAL_FORCE_STATIC_EXECUTABLE := true
-LOCAL_C_INCLUDES += external/zlib external/bzip2
+LOCAL_C_INCLUDES += external/zlib external/bzip2 system/core/mkbootimg
 LOCAL_STATIC_LIBRARIES += libz libbz
 
 include $(BUILD_HOST_EXECUTABLE)
diff --git a/applypatch/imgdiff.c b/applypatch/imgdiff.c
index 05c4f25..625a2cf 100644
--- a/applypatch/imgdiff.c
+++ b/applypatch/imgdiff.c
@@ -132,6 +132,7 @@
 #include "zlib.h"
 #include "imgdiff.h"
 #include "utils.h"
+#include "bootimg.h"
 
 typedef struct {
   int type;             // CHUNK_NORMAL, CHUNK_DEFLATE
@@ -400,10 +401,17 @@ unsigned char* ReadImage(const char* filename,
   *num_chunks = 0;
   *chunks = NULL;
 
+  // Search the magic number 1f8b0800 only from the ramdisk page
+  // to avoid spurious occurance of the magic number in the kernel page.
+  struct boot_img_hdr *hdr = (struct boot_img_hdr*)img;
+  int kern_pages = (hdr->kernel_size + hdr->page_size - 1) / hdr->page_size;
+  unsigned char* p_ramdisk = img + (1 + kern_pages) * hdr->page_size;
+
   while (pos < st.st_size) {
     unsigned char* p = img+pos;
 
-    if (st.st_size - pos >= 4 &&
+    if (p >= p_ramdisk &&
+        st.st_size - pos >= 4 &&
         p[0] == 0x1f && p[1] == 0x8b &&
         p[2] == 0x08 &&    // deflate compression
         p[3] == 0x00) {    // no header flags
@@ -504,7 +512,8 @@ unsigned char* ReadImage(const char* filename,
       curr->data = p;
 
       for (curr->len = 0; curr->len < (st.st_size - pos); ++curr->len) {
-        if (p[curr->len] == 0x1f &&
+        if (p + curr->len >= p_ramdisk &&
+            p[curr->len] == 0x1f &&
             p[curr->len+1] == 0x8b &&
             p[curr->len+2] == 0x08 &&
             p[curr->len+3] == 0x00) {
-- 
2.1.0

